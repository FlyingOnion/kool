// Code generated by koolbuilder. DO NOT EDIT.

package main

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/FlyingOnion/kool"
	"github.com/spf13/pflag"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/workqueue"
	"k8s.io/klog/v2"
{{ range .Imports }}
	{{ .Alias }} {{ quote .Pkg -}}
{{ end }}
)

func mustGetOrLogFatal[T any](v T, err error) T {
	if err != nil {
		klog.Fatal(err)
	}
	return v
}

func main() {
	var kubeconfig string
	var master string

	pflag.StringVar(&kubeconfig, "kubeconfig", "", "absolute path to the kubeconfig file")
	pflag.StringVar(&master, "master", "", "master url")
	pflag.Parse()

	config := mustGetOrLogFatal(clientcmd.BuildConfigFromFlags(master, kubeconfig))
	client := mustGetOrLogFatal(rest.RESTClientFor(config))

	{{ range .InformerInits -}}
	{{ . }}
	{{ end -}}
	
	queue := workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter())

	controller := New{{ .Name }}({{ range .Resources }}{{ .LowerKind }}Informer, {{ end }}queue, {{ .Retry }})

	sigC := make(chan os.Signal, 1)
	signal.Notify(sigC, syscall.SIGINT, syscall.SIGTERM)

	ctx, cancel := context.WithCancel(context.Background())

	go controller.Run(ctx, 1)

	select {
	case sig := <-sigC:
		klog.Infof("Received signal: %s", sig)
		signal.Stop(sigC)
		cancel()
	case <-ctx.Done():
	}
}